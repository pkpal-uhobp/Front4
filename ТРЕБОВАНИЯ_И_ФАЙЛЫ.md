# Соответствие проекта требованиям технического задания

## 1. Работа с дорожной картой (25%)

### ✅ 10% - Корректная загрузка и парсинг JSON-файла

**Файлы:**

-   `src/components/RoadmapImporter.jsx` - компонент загрузки файла через drag-and-drop и выбор файла
-   `src/hooks/useTechnologies.js` (строки 96-133) - функция `importRoadmap()` с валидацией структуры JSON:
    -   Проверка наличия `title`, `items`
    -   Валидация каждого пункта (обязательные поля: `id`, `title`)
    -   Маппинг данных в правильную структуру
-   `src/pages/Home.jsx` (строки 20-30) - использование `RoadmapImporter` для первичной загрузки
-   `src/pages/AddTechnology.jsx` - страница загрузки новой карты
-   `src/hooks/useLocalStorage.js` - сохранение загруженной карты в localStorage с ключом `'roadmap'`

**Отображение структуры:**

-   `src/pages/Home.jsx` - отображает название и описание карты после загрузки
-   `src/pages/TechnologyList.jsx` - отображает все пункты карты в виде сетки
-   `src/pages/Dashboard.jsx` - отображает статистику по карте

**Пример кода - валидация и импорт:**

```javascript
// src/hooks/useTechnologies.js (строки 96-133)
const importRoadmap = useCallback(
    (data) => {
        // Проверка базовой структуры
        if (!data || typeof data !== 'object') {
            throw new Error('Неверный формат файла: ожидается JSON объект');
        }
        if (!data.title || typeof data.title !== 'string') {
            throw new Error(
                'Неверный формат файла: отсутствует название карты (title)'
            );
        }
        if (!Array.isArray(data.items)) {
            throw new Error(
                'Неверный формат файла: отсутствует массив пунктов (items)'
            );
        }

        // Валидация каждого пункта
        for (const item of data.items) {
            if (!item.id) {
                throw new Error(
                    'Неверный формат файла: каждый пункт должен иметь уникальный идентификатор (id)'
                );
            }
            if (!item.title || typeof item.title !== 'string') {
                throw new Error(
                    `Неверный формат файла: пункт ${item.id} должен иметь название (title)`
                );
            }
        }

        // Сохранение в правильной структуре
        setRoadmap({
            title: data.title,
            description: data.description || '',
            items: data.items.map((item) => ({
                id: item.id,
                title: item.title,
                description: item.description || '',
                resources: item.resources || [],
            })),
        });

        // Сохранение прогресса, если он есть в файле
        if (data.userProgress) {
            setUserProgress(data.userProgress);
        } else {
            setUserProgress({});
        }
    },
    [setRoadmap, setUserProgress]
);
```

**Пример использования:**

```javascript
// src/pages/AddTechnology.jsx
const AddTechnology = ({ onNavigate }) => {
    const navigate = useNavigate();

    const handleImport = (data) => {
        try {
            importRoadmap(data);
            setSuccess(true);
            setError(null);
            setTimeout(() => {
                if (onNavigate) {
                    onNavigate(1); // Переход на вкладку "Технологии" без изменения URL
                }
            }, 1500);
        } catch (err) {
            setError(err.message);
            setSuccess(false);
        }
    };
};
```

### ✅ 10% - Функция экспорта текущего состояния карты

**Файлы:**

-   `src/hooks/useTechnologies.js` (строки 135-143) - функция `exportRoadmap()`:
    -   Экспортирует `roadmap` с добавлением `userProgress`
    -   Добавляет поле `exportedAt` с датой экспорта
-   `src/pages/TechnologyList.jsx` (строки 78-93) - функция `handleExport()`:
    -   Вызывает `exportRoadmap()`
    -   Создает Blob и скачивает JSON-файл
    -   Название файла формируется из названия карты
-   `src/components/QuickActions.jsx` - кнопка экспорта в панели быстрых действий

**Пример кода - экспорт:**

```javascript
// src/hooks/useTechnologies.js (строки 135-143)
const exportRoadmap = useCallback(() => {
    if (!roadmap) return null;

    return {
        ...roadmap,
        userProgress, // Все пользовательские данные (статусы, заметки, дедлайны)
        exportedAt: new Date().toISOString(), // Метка времени экспорта
    };
}, [roadmap, userProgress]);
```

**Пример кода - скачивание файла:**

```javascript
// src/pages/TechnologyList.jsx (строки 78-93)
const handleExport = () => {
    const data = exportRoadmap();
    if (!data) return;

    // Создание Blob с JSON данными
    const blob = new Blob([JSON.stringify(data, null, 2)], {
        type: 'application/json',
    });

    // Создание временной ссылки для скачивания
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${roadmap.title.replace(/\s+/g, '_')}_progress.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url); // Освобождение памяти
};
```

**Структура экспортируемого файла:**

```json
{
  "title": "React Roadmap",
  "description": "Roadmap for learning React",
  "items": [...],
  "userProgress": {
    "jsx": {
      "status": "completed",
      "notes": "Изучил основы JSX",
      "deadline": "2024-01-15"
    },
    ...
  },
  "exportedAt": "2024-01-20T12:00:00.000Z"
}
```

### ✅ 5% - Обработка ошибок при загрузке неверного формата

**Файлы:**

-   `src/components/RoadmapImporter.jsx` - обработка ошибок:
    -   Проверка типа файла (`.json` или `application/json`)
    -   Try-catch при парсинге JSON
    -   Отображение ошибок через `Alert` компонент Material UI
-   `src/hooks/useTechnologies.js` (строки 98-115) - валидация структуры в `importRoadmap()`:
    -   Проверка всех обязательных полей
    -   Выброс понятных ошибок с описанием проблемы
-   `src/pages/AddTechnology.jsx` (строки 21-33) - обработка ошибок при импорте с отображением в `Alert`
-   `src/pages/Home.jsx` (строки 24-30) - обработка ошибок импорта с логированием в консоль

---

## 2. Интерфейс и маршрутизация (30%)

### ✅ 10% - Главная страница с карточками в сетке

**Файлы:**

-   `src/pages/TechnologyList.jsx` - основная страница со списком:
    -   `Grid container` с адаптивной сеткой (строки 330-339)
    -   Карточки отображаются в сетке `xs: 12, sm: 6, md: 4`
-   `src/components/SimpleTechCard.jsx` - компонент карточки:
    -   Визуальное отображение статуса (строки 65-66): цветная верхняя граница (`borderTop: 4`)
    -   Цвет границы зависит от статуса через `STATUS_COLORS[status]`
    -   Иконка статуса в чипе (строки 99-119): `STATUS_ICONS[status]`
    -   Цвет фона при просроченном дедлайне (строки 67-69)

### ✅ 10% - Детальная страница с React Router

**Реализация (гибридная модель):**

-   `src/App.jsx` - гибридная модель маршрутизации:
    -   Роут `/technology/:id` ТОЛЬКО для детальной страницы (строка 86-88)
    -   Основные вкладки (Главная, Технологии, Статистика, Добавить) рендерятся через состояние `activeTab` без изменения URL (строка 58-71)
    -   URL меняется ТОЛЬКО при переходе на детальную страницу
-   `src/pages/TechnologyDetail.jsx` - компонент детальной информации:
    -   Использует `useParams()` для получения `id` из URL (строка 29)
    -   Использует `Link` из `react-router-dom` для навигации
    -   Кнопка "Назад к списку" возвращает на список через `navigate(-1)` или использует `useNavigate`
    -   Кнопка "Вернуться к списку" внизу страницы
-   `src/components/Navigation.jsx` - навигация через состояние:
    -   Использует состояние `activeTab` и `onTabChange` для переключения вкладок
    -   URL НЕ меняется при переключении между вкладками
    -   Визуальное выделение активной вкладки через `activeTab === item.index`

**Пример кода - гибридная настройка роутинга:**

```javascript
// src/App.jsx
import { useState } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

// Внутренний компонент для работы с роутингом
function AppContent() {
    const [activeTab, setActiveTab] = useState(0);

    const handleTabChange = (newValue) => {
        setActiveTab(newValue);
    };

    const renderMainContent = () => {
        switch (activeTab) {
            case 0:
                return <Home onNavigate={handleTabChange} />;
            case 1:
                return <TechnologyList onNavigate={handleTabChange} />;
            case 2:
                return <Dashboard onNavigate={handleTabChange} />;
            case 3:
                return <AddTechnology onNavigate={handleTabChange} />;
            default:
                return <Home onNavigate={handleTabChange} />;
        }
    };

    return (
        <Box
            sx={{
                display: 'flex',
                flexDirection: 'column',
                minHeight: '100vh',
            }}
        >
            <Navigation activeTab={activeTab} onTabChange={handleTabChange} />
            <Box component="main" sx={{ flexGrow: 1 }}>
                <Routes>
                    {/* Детальная страница использует роутинг */}
                    <Route
                        path="/technology/:id"
                        element={<TechnologyDetail />}
                    />
                    {/* Остальные страницы рендерятся без роутинга */}
                    <Route path="*" element={renderMainContent()} />
                </Routes>
            </Box>
        </Box>
    );
}

function App() {
    return (
        <ThemeProvider theme={theme}>
            <CssBaseline />
            <Router>
                <AppContent />
            </Router>
        </ThemeProvider>
    );
}
```

**Пример кода - навигация через состояние (без изменения URL):**

```javascript
// src/components/Navigation.jsx
const Navigation = ({ activeTab, onTabChange }) => {
    const handleNavClick = (index) => {
        onTabChange(index); // URL не меняется
    };

    return (
        <AppBar position="static">
            <Box>
                {navItems.map((item) => (
                    <Button
                        key={item.index}
                        onClick={() => handleNavClick(item.index)}
                        color="inherit"
                        sx={{
                            backgroundColor:
                                activeTab === item.index
                                    ? 'rgba(255,255,255,0.15)'
                                    : 'transparent',
                        }}
                    >
                        {item.label}
                    </Button>
                ))}
            </Box>
        </AppBar>
    );
};
```

**Пример кода - получение параметров из URL:**

```javascript
// src/pages/TechnologyDetail.jsx (строки 28-36)
import { useParams, Link, useNavigate } from 'react-router-dom';

const TechnologyDetail = () => {
    const { id } = useParams(); // Получение id из URL: /technology/:id
    const navigate = useNavigate();
    const { getTechnologyById, updateStatus, updateNotes, updateDeadline } =
        useTechnologies();

    // Получение данных технологии по id
    const technology = useMemo(
        () => getTechnologyById(id),
        [id, getTechnologyById]
    );

    // Возврат на предыдущую страницу (URL меняется обратно)
    const handleBack = () => {
        navigate(-1); // Или можно использовать navigate('/') для возврата на главную
    };
    // ...
};
```

**Пример кода - навигация к детальной странице (URL меняется):**

```javascript
// src/pages/TechnologyList.jsx (строки 70-72)
import { useNavigate } from 'react-router-dom';

const TechnologyList = ({ onNavigate }) => {
    const navigate = useNavigate(); // Используется только для детальной страницы

    const handleCardClick = (id) => {
        navigate(`/technology/${id}`); // URL меняется на /technology/:id
    };
    // ...
};
```

**Пример кода - кнопка возврата:**

```javascript
// src/pages/TechnologyDetail.jsx
import { Link, useNavigate } from 'react-router-dom';

const TechnologyDetail = () => {
    const navigate = useNavigate();

    return (
        <Container maxWidth="md" sx={{ py: 4 }}>
            {/* Кнопка вверху страницы */}
            <Button
                onClick={() => navigate(-1)}
                startIcon={<ArrowBackIcon />}
                sx={{ mb: 3 }}
            >
                Назад к списку
            </Button>

            {/* ... контент страницы ... */}

            {/* Кнопка внизу страницы */}
            <Box
                sx={{ display: 'flex', justifyContent: 'space-between', mt: 3 }}
            >
                <Button
                    onClick={() => navigate(-1)}
                    variant="outlined"
                    startIcon={<ArrowBackIcon />}
                >
                    Вернуться к списку
                </Button>
            </Box>
        </Container>
    );
};
```

**Функциональность:**

-   ✅ Полная информация о пункте отображается
-   ✅ URL изменяется ТОЛЬКО при переходе на детальную страницу (`/technology/:id`)
-   ✅ URL НЕ меняется при переключении между основными вкладками (одностраничное приложение)
-   ✅ Кнопка возврата на предыдущую страницу
-   ✅ Данные соответствуют выбранной карточке (получается `id` из URL)
-   ✅ React Router используется ТОЛЬКО для детальной страницы (соответствие ТЗ)

### ✅ 10% - Удобство использования интерфейса

**Файлы:**

-   `src/components/Navigation.jsx` - интуитивная навигация:
    -   Визуальное выделение активной вкладки через `activeTab === item.index`
    -   Адаптивное меню для мобильных (Drawer)
    -   Навигация через состояние (`onTabChange`), URL не меняется
-   `src/pages/TechnologyList.jsx` - корректная навигация:
    -   При клике на карточку используется `navigate(\`/technology/${id}\`)` для изменения URL (строка 71)
    -   Получает `onNavigate` для переключения вкладок без изменения URL
-   `src/pages/TechnologyDetail.jsx` - правильная работа с роутингом:
    -   Использует `useParams()` для получения `id` из URL
    -   Использует `useNavigate()` для возврата на предыдущую страницу
    -   Корректное отображение данных выбранного пункта
-   `src/App.jsx` - гибридная настройка роутинга:
    -   `BrowserRouter` оборачивает всё приложение
    -   `Routes` и `Route` ТОЛЬКО для детальной страницы `/technology/:id`
    -   Основные страницы рендерятся через условный рендеринг (`renderMainContent()`)

---

## 3. Функциональность заметок и статусов (35%)

### ✅ 15% - Работа с заметками

**Файлы:**

-   `src/pages/TechnologyDetail.jsx` (строки 242-284) - секция заметок:
    -   Текстовое поле `TextField` с `multiline` и `rows={6}` (строки 256-264)
    -   Локальное состояние `localNotes` для отслеживания изменений (строка 32)
    -   Функция `handleSave()` сохраняет заметки (строки 61-70)
    -   Функция `updateNotes()` вызывается из хука (строка 67)
    -   Кнопка удаления заметок (строки 247-253)
-   `src/hooks/useTechnologies.js` (строки 76-84) - функция `updateNotes()`:
    -   Обновляет `userProgress[id].notes` в localStorage
-   `src/hooks/useLocalStorage.js` - сохранение в localStorage
-   `src/pages/TechnologyDetail.jsx` (строки 37-42) - синхронизация состояния:
    -   `useEffect` загружает сохраненные заметки при открытии
    -   Заметки отображаются при повторном открытии пункта
-   `src/components/SimpleTechCard.jsx` (строки 52, 138-177) - отображение заметок на карточке:
    -   Проверка наличия заметок `hasNotes`
    -   Секция с сокращенными заметками (до 2 строк)
    -   Чип "Заметки" в индикаторах

**Пример кода - состояние и синхронизация:**

```javascript
// src/pages/TechnologyDetail.jsx (строки 38-47)
const [localNotes, setLocalNotes] = useState('');
const [localDeadline, setLocalDeadline] = useState('');
const [saved, setSaved] = useState(false);

// Синхронизация локального состояния с данными из localStorage
useEffect(() => {
    if (technology) {
        setLocalNotes(technology.notes || '');
        setLocalDeadline(technology.deadline || '');
    }
}, [technology]);
```

**Пример кода - сохранение заметок:**

```javascript
// src/pages/TechnologyDetail.jsx (строки 61-75)
const handleSave = () => {
    if (hasNotesChanges) {
        // Использование flushSync для немедленного обновления DOM
        flushSync(() => {
            updateNotes(id, localNotes);
        });
    }
    if (hasDeadlineChanges) {
        flushSync(() => {
            updateDeadline(id, localDeadline);
        });
    }

    setSaved(true);
    setTimeout(() => setSaved(false), 3000); // Показ уведомления на 3 секунды
};

// Проверка наличия изменений
const hasNotesChanges = useMemo(() => {
    if (!technology) return false;
    return localNotes !== (technology.notes || '');
}, [localNotes, technology]);
```

**Пример кода - функция обновления в хуке:**

```javascript
// src/hooks/useTechnologies.js (строки 76-84)
const updateNotes = useCallback(
    (id, notes) => {
        setUserProgress((prev) => ({
            ...prev,
            [id]: {
                ...prev[id], // Сохранение существующих данных (статус, дедлайн)
                notes, // Обновление заметок
            },
        }));
    },
    [setUserProgress]
);
```

**Пример кода - UI для заметок:**

```javascript
// src/pages/TechnologyDetail.jsx (примерная структура)
<Paper sx={{ p: 3 }}>
    <Box
        sx={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            mb: 2,
        }}
    >
        <Typography variant="h6">Личные заметки</Typography>
        {localNotes && (
            <Tooltip title="Удалить заметку">
                <IconButton
                    size="small"
                    color="error"
                    onClick={handleDeleteNotes}
                >
                    <DeleteIcon />
                </IconButton>
            </Tooltip>
        )}
    </Box>

    <TextField
        fullWidth
        multiline
        rows={6}
        placeholder="Добавьте свои заметки, конспект, полезные команды или ссылки на решенные задачи..."
        value={localNotes}
        onChange={(e) => setLocalNotes(e.target.value)}
        variant="outlined"
    />

    {hasChanges && (
        <Button
            variant="contained"
            color="primary"
            startIcon={<SaveIcon />}
            onClick={handleSave}
            sx={{ mt: 2 }}
        >
            Сохранить изменения
        </Button>
    )}

    {saved && (
        <Alert severity="success" sx={{ mt: 2 }}>
            Изменения сохранены!
        </Alert>
    )}
</Paper>
```

**Пример кода - отображение заметок на карточке:**

```javascript
// src/components/SimpleTechCard.jsx
const hasNotes = notes && notes.trim().length > 0;

{
    hasNotes && (
        <Box
            sx={{
                mt: 1,
                p: 1.5,
                backgroundColor: 'rgba(33, 150, 243, 0.08)',
                borderLeft: 3,
                borderColor: 'primary.main',
                borderRadius: 1,
            }}
        >
            <Chip
                label="Заметки"
                size="small"
                sx={{ mb: 1, height: 20, fontSize: '0.7rem' }}
            />
            <Typography
                variant="body2"
                color="text.secondary"
                sx={{
                    display: '-webkit-box',
                    WebkitLineClamp: 2,
                    WebkitBoxOrient: 'vertical',
                    overflow: 'hidden',
                }}
            >
                {notes}
            </Typography>
        </Box>
    );
}
```

### ✅ 10% - Управление статусами (минимум 3 состояния)

**Файлы:**

-   `src/hooks/useTechnologies.js` (строки 4-20) - определение статусов:
    -   `STATUS.NOT_STARTED` - "Не начат"
    -   `STATUS.IN_PROGRESS` - "В работе"
    -   `STATUS.COMPLETED` - "Выполнено"
    -   Цвета и иконки для каждого статуса
-   `src/hooks/useTechnologies.js` (строки 66-74) - функция `updateStatus()`
-   `src/pages/TechnologyDetail.jsx` (строки 183-203) - управление статусом на детальной странице:
    -   Кнопки для переключения между 3 статусами
    -   Визуальное выделение текущего статуса
-   `src/components/SimpleTechCard.jsx` (строки 98-119) - отображение статуса на карточке:
    -   Чип со статусом, иконкой и цветом
    -   Цветная верхняя граница карточки
    -   Клик по чипу меняет статус (строки 42-47)
-   `src/components/SimpleTechCard.jsx` (строки 25-29) - логика переключения статусов:
    -   `NEXT_STATUS` - циклическое переключение

**Пример кода - определение статусов:**

```javascript
// src/hooks/useTechnologies.js (строки 4-20)
export const STATUS = {
    NOT_STARTED: 'not_started',
    IN_PROGRESS: 'in_progress',
    COMPLETED: 'completed',
};

export const STATUS_LABELS = {
    [STATUS.NOT_STARTED]: 'Не начат',
    [STATUS.IN_PROGRESS]: 'В работе',
    [STATUS.COMPLETED]: 'Выполнено',
};

export const STATUS_COLORS = {
    [STATUS.NOT_STARTED]: '#9e9e9e', // Серый
    [STATUS.IN_PROGRESS]: '#ff9800', // Оранжевый
    [STATUS.COMPLETED]: '#4caf50', // Зеленый
};
```

**Пример кода - функция обновления статуса:**

```javascript
// src/hooks/useTechnologies.js (строки 66-74)
const updateStatus = useCallback(
    (id, status) => {
        setUserProgress((prev) => ({
            ...prev,
            [id]: {
                ...prev[id], // Сохранение заметок и дедлайна
                status, // Обновление статуса
            },
        }));
    },
    [setUserProgress]
);
```

**Пример кода - управление статусом на детальной странице:**

```javascript
// src/pages/TechnologyDetail.jsx (примерная структура)
const handleStatusChange = (newStatus) => {
    updateStatus(id, newStatus);
};

const currentStatus = technology.status || STATUS.NOT_STARTED;

<Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap', mb: 3 }}>
    {Object.entries(STATUS_LABELS).map(([key, label]) => (
        <Button
            key={key}
            variant={currentStatus === key ? 'contained' : 'outlined'}
            onClick={() => handleStatusChange(key)}
            sx={{
                borderColor: STATUS_COLORS[key],
                color: currentStatus === key ? 'white' : STATUS_COLORS[key],
                backgroundColor:
                    currentStatus === key ? STATUS_COLORS[key] : 'transparent',
                '&:hover': {
                    backgroundColor:
                        currentStatus === key
                            ? STATUS_COLORS[key]
                            : `${STATUS_COLORS[key]}20`,
                },
            }}
        >
            {label}
        </Button>
    ))}
</Box>;
```

**Пример кода - отображение статуса на карточке:**

```javascript
// src/components/SimpleTechCard.jsx (строки 56-66)
<Card
    sx={{
        borderTop: 4,
        borderColor: STATUS_COLORS[status] || STATUS_COLORS.not_started,
        // ...
    }}
>
    {/* ... */}
    <Chip
        label={STATUS_LABELS[status]}
        icon={STATUS_ICONS[status]}
        sx={{
            backgroundColor: STATUS_COLORS[status],
            color: 'white',
        }}
        onClick={handleStatusClick}
    />
</Card>
```

**Пример кода - циклическое переключение статусов:**

```javascript
// src/components/SimpleTechCard.jsx (строки 25-29)
const NEXT_STATUS = {
    [STATUS.NOT_STARTED]: STATUS.IN_PROGRESS,
    [STATUS.IN_PROGRESS]: STATUS.COMPLETED,
    [STATUS.COMPLETED]: STATUS.NOT_STARTED,
};

const handleStatusClick = (e) => {
    e.stopPropagation(); // Предотвращение открытия карточки
    if (onStatusChange) {
        onStatusChange(id, NEXT_STATUS[status]); // Циклическое переключение
    }
};
```

### ✅ 10% - Расчет и отображение прогресса

**Файлы:**

-   `src/hooks/useTechnologies.js` (строки 50-54) - расчет прогресса:
    -   `progress` вычисляется как процент выполненных пунктов
    -   Использует `useMemo` для пересчета при изменении статусов
-   `src/hooks/useTechnologies.js` (строки 56-64) - расчет статистики:
    -   `stats` содержит: `total`, `completed`, `inProgress`, `notStarted`
-   `src/components/ProgressBar.jsx` - компонент прогресс-бара:
    -   Отображение процентов
    -   Визуальный прогресс-бар
    -   Подпись с количеством выполненных пунктов
-   `src/pages/Home.jsx` (строки 79-90) - отображение прогресса на главной:
    -   Прогресс-бар с подписью
    -   Карточки со статистикой (строки 93-130)
-   `src/pages/TechnologyList.jsx` (строки 146-153) - прогресс-бар на странице списка
-   `src/pages/Dashboard.jsx` (строки 81-142) - детальная статистика:
    -   Карточки с количеством по каждому статусу
    -   Прогресс-бар (строки 145-156)
    -   Процент выполнения (строки 127-141)

**Пример кода - расчет прогресса:**

```javascript
// src/hooks/useTechnologies.js (строки 50-64)
// Получение всех технологий с их статусами
const technologies = useMemo(() => {
    if (!roadmap || !roadmap.items) return [];
    return roadmap.items.map((item) => ({
        ...item,
        status: userProgress[item.id]?.status || STATUS.NOT_STARTED,
        notes: userProgress[item.id]?.notes || '',
        deadline: userProgress[item.id]?.deadline || null,
    }));
}, [roadmap, userProgress]);

// Расчет процента выполнения
const progress = useMemo(() => {
    if (technologies.length === 0) return 0;
    const completed = technologies.filter(
        (t) => t.status === STATUS.COMPLETED
    ).length;
    return Math.round((completed / technologies.length) * 100);
}, [technologies]);

// Расчет детальной статистики
const stats = useMemo(() => {
    const total = technologies.length;
    const completed = technologies.filter(
        (t) => t.status === STATUS.COMPLETED
    ).length;
    const inProgress = technologies.filter(
        (t) => t.status === STATUS.IN_PROGRESS
    ).length;
    const notStarted = technologies.filter(
        (t) => t.status === STATUS.NOT_STARTED
    ).length;

    return { total, completed, inProgress, notStarted };
}, [technologies]);
```

**Пример кода - компонент прогресс-бара:**

```javascript
// src/components/ProgressBar.jsx
const ProgressBar = ({
    value,
    label = 'Прогресс',
    showPercentage = true,
    stats = null,
}) => {
    const normalizedValue = Math.min(100, Math.max(0, value));

    return (
        <Box sx={{ width: '100%' }}>
            <Box
                sx={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    mb: 0.5,
                }}
            >
                <Typography
                    variant="body2"
                    color="text.secondary"
                    fontWeight={500}
                >
                    {label}
                </Typography>
                {showPercentage && (
                    <Typography
                        variant="body2"
                        color="text.secondary"
                        fontWeight={600}
                    >
                        {normalizedValue}%
                    </Typography>
                )}
            </Box>

            <LinearProgress
                variant="determinate"
                value={normalizedValue}
                sx={{
                    height: 12,
                    borderRadius: 6,
                    backgroundColor: 'rgba(0,0,0,0.1)',
                    '& .MuiLinearProgress-bar': {
                        borderRadius: 6,
                        transition: 'transform 0.5s ease-in-out',
                        backgroundColor:
                            normalizedValue < 25
                                ? '#f44336'
                                : normalizedValue < 50
                                ? '#ff9800'
                                : normalizedValue < 75
                                ? '#ffc107'
                                : '#4caf50',
                    },
                }}
            />

            {stats && (
                <Box
                    sx={{
                        display: 'flex',
                        justifyContent: 'space-between',
                        mt: 0.5,
                    }}
                >
                    <Typography variant="caption" color="text.secondary">
                        Выполнено: {stats.completed}
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                        В работе: {stats.inProgress}
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                        Не начато: {stats.notStarted}
                    </Typography>
                </Box>
            )}
        </Box>
    );
};
```

**Пример кода - отображение прогресса на главной странице:**

```javascript
// src/pages/Home.jsx
<Paper sx={{ p: 3, mb: 4 }}>
    <Typography variant="h6" gutterBottom>
        Общий прогресс
    </Typography>
    <ProgressBar
        value={progress}
        label={`${stats.completed} из ${stats.total} пунктов выполнено`}
        height={16}
        color="auto"
        stats={stats}
    />
</Paper>

<Grid container spacing={3}>
    <Grid size={{ xs: 12, sm: 4 }}>
        <Card sx={{ borderLeft: 4, borderColor: 'success.main' }}>
            <CardContent>
                <Typography variant="h3" color="success.main" fontWeight="bold">
                    {stats.completed}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                    Выполнено
                </Typography>
            </CardContent>
        </Card>
    </Grid>
    {/* ... другие карточки статистики ... */}
</Grid>
```

**Автоматический пересчет:**

-   Все вычисления используют `useMemo` с зависимостью от `technologies`
-   `technologies` зависит от `userProgress`
-   При изменении статуса через `updateStatus()` автоматически пересчитывается прогресс:

```javascript
// Цепочка обновлений:
updateStatus(id, newStatus)
  → setUserProgress обновляет localStorage
  → technologies пересчитывается (зависит от userProgress)
  → progress и stats пересчитываются (зависят от technologies)
  → UI автоматически обновляется
```

---

## 4. Качество кода (10%)

### ✅ 5% - Структура кода, компоненты, принципы React

**Структура проекта:**

```
src/
├── components/          # Переиспользуемые компоненты
│   ├── Modal.jsx
│   ├── Navigation.jsx
│   ├── ProgressBar.jsx
│   ├── QuickActions.jsx
│   ├── RoadmapImporter.jsx
│   └── SimpleTechCard.jsx
├── hooks/              # Кастомные хуки
│   ├── useLocalStorage.js
│   ├── useTechnologies.js
│   └── useTechnologiesApi.js
├── pages/              # Страницы/вкладки приложения
│   ├── AddTechnology.jsx
│   ├── Dashboard.jsx
│   ├── Home.jsx
│   ├── TechnologyDetail.jsx
│   └── TechnologyList.jsx
├── App.jsx             # Корневой компонент
└── main.jsx            # Точка входа
```

**Соответствие принципам React:**

-   ✅ Использование функциональных компонентов
-   ✅ Хуки вместо классовых компонентов
-   ✅ `useState`, `useEffect`, `useMemo`, `useCallback` для управления состоянием
-   ✅ Нет мутаций состояния (immutable updates через spread оператор)
-   ✅ Правильное использование ключей в списках (`key={tech.id}`)
-   ✅ Разделение ответственности: хуки для логики, компоненты для UI

**Примеры правильного кода:**

-   `src/hooks/useTechnologies.js` (строка 67) - immutable update:
    ```javascript
    setUserProgress((prev) => ({
        ...prev,
        [id]: { ...prev[id], status },
    }));
    ```
-   `src/pages/TechnologyDetail.jsx` - правильное использование `useEffect` для синхронизации
-   `src/components/SimpleTechCard.jsx` - переиспользуемый компонент

### ✅ 5% - Запуск проекта без ошибок

**Файлы:**

-   `package.json` - правильная конфигурация:
    -   Скрипты: `start`, `build`, `lint`
    -   Все зависимости указаны
    -   Нет критических ошибок в зависимостях
-   `vite.config.js` - конфигурация Vite (если есть)
-   `src/main.jsx` - точка входа приложения
-   `index.html` - HTML шаблон

**Проверка:**

-   ✅ `npm install` - установка зависимостей работает
-   ✅ `npm start` - запуск dev-сервера работает
-   ✅ Нет ошибок в консоли браузера (при корректном использовании)
-   ✅ Линтер настроен (`eslint.config.js`)

---

## Дополнительные замечания

### ✅ Полное соответствие ТЗ

**React Router:** Проект полностью соответствует требованиям ТЗ. Используется гибридная модель:

-   React Router применяется ТОЛЬКО для детальной страницы (`/technology/:id`)
-   Основные вкладки (Главная, Технологии, Статистика, Добавить) работают через состояние без изменения URL
-   Это одностраничное приложение (SPA), где URL меняется только при переходе на детальную страницу

**Реализация:**

-   ✅ `BrowserRouter` используется для маршрутизации
-   ✅ Детальная страница реализована через роут `/technology/:id` (URL меняется)
-   ✅ Основные вкладки работают через состояние `activeTab` (URL не меняется)
-   ✅ Кнопка возврата на предыдущую страницу через `navigate(-1)`
-   ✅ Навигация к детальной странице через `useNavigate()` (URL меняется)
-   ✅ Одностраничное приложение (SPA) без перезагрузок

### ✅ Дополнительные функции (не в ТЗ, но реализованы)

-   Фильтрация по статусам и поиск
-   Массовые действия (отметить все выполненными, сбросить прогресс)
-   Экспорт прогресса
-   Дедлайны и индикация просроченных задач
-   Адаптивный дизайн для мобильных устройств
-   Синхронизация данных между вкладками браузера
